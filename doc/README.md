\maketitle
Introduction {#introduction .unnumbered .unnumbered}
============

This document is work in progress. In the first version deemed fit for
release, this pink box will no longer be here.

These tutorials show you how to make [ethnodes]{acronym-label="ethnode"
acronym-form="plural+short"} communicate with each other using the
`go-ethereum` code base. They do _not_ show you _how_ to program, nor
does it provide entry-level familiarity to the `golang` programming
language, which `go-ethereum` is written in.

For the latter I can warmly recommend taking the official "go tour", but
be warned; although `golang` aims at providing friendly access to fairly
low-level operations, it's still fairly low-level. So if you come from
the less cumbersome environment of web-scripting and such, you're
probably in for a challenge.

The Ethersphere, like its crypto comrades, dabbles quite a bit in moving
individual bytes around before crunching them with big number math.
However, most of the code we shall see fortunately manages to steer
clear of that, and concentrates on some nice, magic function calls that
spares us a few pints of elbow grease.

The meaty parts of this document are code examples that all centre on
runnable mini-applications that reveal features and structure in small
incremental steps. And they are even grouped in themes that
incrementally add to the complexity of components of the code stack that
we will be using in everyday p2p life.

In the current version of this document, the layers we will peel are as
follows:

1.  **The [p2pserver]{acronym-label="p2pserver"
    acronym-form="singular+short"}**; connections and messages

2.  **Remote Procedure Calls**; defining and using APIs

3.  **Services**; bringing protocols and APIs together

4.  **Pss**: relay messages across peer-to-peer connections

# p2p in Ethereum

\[...\]

# the code examples

## Server minimalism

The best way to learn is to remove all distractions, so let's stick with
the bare-bear necessities first. In this example we merely create an
_instance_ of the [p2pserver]{acronym-label="p2pserver"
acronym-form="singular+short"}, _start_ it and stop it again. Not very
useful, but it's the start of something great, promise!

By _starting_ we mean that the `UDP` and `TCP` listener sockets are
opened, upon which the server will:

- wait for connections

- be able to connect to other [nodep2ps]{acronym-label="nodep2p"
  acronym-form="plural+short"}

<!-- -->

    privkey, err := crypto.GenerateKey()
    if err != nil {
    	demo.LogCrit("Generate private key failed", "err", err)
    }

The first step is to create the [node]{acronym-label="node"
acronym-form="singular+abbrv"}'s _private key_. The public key derived
from it will be the public identity of the [node]{acronym-label="node"
acronym-form="singular+abbrv"}. Don't worry; the private key is
generated by random, chosen from a range of numbers greater than the
particle count of the entire universe. It will be quite unique.

    cfg := p2p.Config{
    	PrivateKey: privkey,
    	Name:       common.MakeName("foo", "42"),
    }
    srv := p2p.Server{
    	Config: cfg,
    }

The private key is passed to the server's configuration, along with an
arbitrary _name_, usually made up by an identifier describing its
codebase, architecture and version number. The name has no practical
significance in the scope of our tutorials, but it is a required field,
and kind of polite to take seriously. There are plenty of other settings
under the hood of the [p2pserver]{acronym-label="p2pserver"
acronym-form="singular+short"}. Luckily, all of them will receive nice
default values when we fire things up.

    // attempt to start the server
    err = srv.Start()
    if err != nil {
    	demo.LogCrit("Start p2p.Server failed", "err", err)
    }

    // inspect the resulting values
    nodeinfo := srv.NodeInfo()
    demo.LogInfo("server started", "enode", nodeinfo.Enode, "name", nodeinfo.Name,
    "ID", nodeinfo.ID, "IP", nodeinfo.IP)

    // bring down the server
    srv.Stop()

**The moment of truth.** If your computer doesn't blow up before then,
you should see a log line in your console showing you some basic
information about your running server, along the lines of[^1]:

\scriptsize
INFO [06-24|22:12:49] server started demolog=\* enode=enode://92f6fa82[\ldots]dc0912ba@[::]:46851
name=foo/v42/linux/go1.8.3 ID=92f6fa82[\ldots]dc0912ba IP=:: caller=A1_Server.go:32

\normalsize
An IP address has now been awarded to us, which spells good news for
future connectivity. Fair enough, the IP field here merely cites the
somewhat cryptic "::", but this is shorthand for `localhost` so we're
good.

The two fields of special interest to us are the `ID` and the `enode`.
See how they contain nearly the same thing? Or rather, how the `enode`
contains the `ID` and a bit more? Here's how the entities we've met so
far fit together:

server

: Holds a private key and controls ip connections.

ID

: The one-of-a-kind public key of the
[p2pserver]{acronym-label="p2pserver"
acronym-form="singular+short"}, derived from its private key (the
one we made up in the start of the example).

enode

: An uri-string that is used when you want to tell a
[p2pserver]{acronym-label="p2pserver" acronym-form="singular+short"}
who to connect to, made up of the server's ID (more on that next)
along with the IP address and port number of the node.

Of course, every time a [p2pserver]{acronym-label="p2pserver"
acronym-form="singular+short"} starts up it might have a different
address or port, so we need to know about those to reach out to it at
all. But we also want to make sure that the connection actually is for
the [node]{acronym-label="node" acronym-form="singular+abbrv"} in
question, and not some other shady node that popped up on that address
and port in the meantime. Therefore we also include the public key. And
if the public key doesn't match, no soup for you.

## Getting hooked up

Now we bring up two of the servers as in the previous example and
connect them. That is, connect one to the other. They act as consenting
adults; the connection will be mutual, or none at all.

    func newServer(privkey *ecdsa.PrivateKey, name string, version string, port int) *p2p.Server {

    	// we need to explicitly allow at least one peer
    	// otherwise the connection attempt will be refused
    	cfg := p2p.Config{
    		PrivateKey: privkey,
    		Name:       common.MakeName(name, version),
    		MaxPeers:   1,
    	}
    	if port > 0 {
    		cfg.ListenAddr = fmt.Sprintf(":%d", port)
    	}
    	srv := &p2p.Server{
    		Config: cfg,
    	}
    	return srv
    }

The code is almost the same as before, except for two things:

We are specifying the _port_ explicitly. It has a default value, but
when we are setting up two servers on the same host we need different
ports for them. Otherwise the OS will complain loudly.

Also, with the `MaxPeers` setting we're telling the server that it will
allow one and only one peer to connect to it. Without this setting the
value will be 0, which means the node will play very hard-to-get and any
attempt of connecting will be coldly rejected. If you believe more is
merrier, which is usually the case in p2p networks, this setting will
usually be higher.

    	srv_one := newServer(privkey_one, "foo", "42", 0)
    	err = srv_one.Start()
    	if err != nil {
    		demo.LogCrit("Start p2p.Server #1 failed", "err", err)
    	}

    	srv_two := newServer(privkey_two, "bar", "666", 31234)
    	err = srv_two.Start()
    	if err != nil {
    		demo.LogCrit("Start p2p.Server #2 failed", "err", err)
    	}

In the same manner as before, we start the two servers. We give the
second different parameters for name, version and port.

    	// get the node instance of the second server
    	node_two := srv_two.Self()

    	// add it as a peer to the first node
    	// the connection and crypto handshake will be performed automatically
    	srv_one.AddPeer(node_two)

The `Self()` call on the server gives you back a
[discovernode]{acronym-label="discovernode"
acronym-form="singular+short"} object. This object represents the server
as a node, and contains all the information needed for a connection. So
we can simply pass this [discovernode]{acronym-label="discovernode"
acronym-form="singular+short"} as an argument to the aptly-named
`AddPeer` method of the server.

    // give the connection a glimpse of time to complete
    time.Sleep(time.Millisecond * 100)

    // inspect the results
    demo.LogInfo("after add", "node one peers", srv_one.Peers(), "node two peers", srv_two.Peers())

The connection is created asynchronously, and might take a split second
to complete. So if we rush into proving that we now have a shiny new
peer in our connection list, we will most certainly be disappointed. So
we give it pleeenty of time a.k.a. 100 milliseconds to complete. In the
next section we'll learn a way more clever way to do this. Anyway you
can rejoice for now: Connection is made. **Victory is ours**.

### A note on nodes

The term `node` used here is one of many notions of node in the
go-ethereum code base, which at some point surely will confuse you. This
flavor of node has to do with finding (discovering) nodes to connect to,
and connect to them. And this specific object holds information specific
to the connection, like IP information and an ID, or pretty much what
makes up the [enode]{acronym-label="enode"
acronym-form="singular+short"} string we mentioned in the last section.
See how it all neatly fits together?

## Know what's going on

So how to we get rid of that unaesthetic and unprecise timeout from the
last example? We use the [peerevents]{acronym-label="peerevent"
acronym-form="plural+short"}, of course. When connections start and
stop, and when messages are sent and received,
[peerevents]{acronym-label="peerevent" acronym-form="plural+short"} are
emitted.

    // set up the event subscription on the first server
    eventC := make(chan *p2p.PeerEvent)
    sub_one := srv_one.SubscribeEvents(eventC)

All you have to do is pass a channel to the `SubscribeEvents` method of
the [p2pserver]{acronym-label="p2pserver"
acronym-form="singular+short"}, and you will start receiving them
through it.

    // listen for events
    go func() {
    	peerevent := <-eventC
    	demo.LogInfo("received peerevent", "type", peerevent.Type, "peer", peerevent.Peer)
    	quitC <- true
    }()

Then fork before the `AddPeer` call, and listen on the channel for an
event. Of course normally we would check what event it is, what peer it
came from and so on and so forth. In this case, however, we're not
really doing much, so we know that the event will be of type "add" and
the peer will be the node we're _not_ subscribing to.

    // PeerEventType is the type of peer events emitted by a p2p.Server
    type PeerEventType string

    const (
    	// PeerEventTypeAdd is the type of event emitted when a peer is added
    	// to a p2p.Server
    	PeerEventTypeAdd PeerEventType = "add"

    	// PeerEventTypeDrop is the type of event emitted when a peer is
    	// dropped from a p2p.Server
    	PeerEventTypeDrop PeerEventType = "drop"

    	// PeerEventTypeMsgSend is the type of event emitted when a
    	// message is successfully sent to a peer
    	PeerEventTypeMsgSend PeerEventType = "msgsend"

    	// PeerEventTypeMsgSend is the type of event emitted when a
    	// message is successfully sent to a peer
    	PeerEventTypeMsgRecv PeerEventType = "msgrecv"
    )

    // PeerEvent is an event emitted when peers are either added or dropped from
    // a p2p.Server or when a message is sent or received on a peer connection
    type PeerEvent struct {
    	Type    PeerEventType   `json:"type"`
    	Peer    enode.ID `json:"peer"`
    	Error   string          `json:"error,omitempty"`
    	MsgCode *uint64         `json:"msg_code,omitempty"`
    	MsgSize *uint32         `json:"msg_size,omitempty"`
    }

A quick look in the `peer.go` file in the `p2p` package tells what kind
of [peerevents]{acronym-label="peerevent" acronym-form="plural+short"}
we have, and how they're stuctured.

    // receives when the event is received
    <-quitC

    // inspect the results
    demo.LogInfo("after add", "node one peers", srv_one.Peers(), "node two peers", srv_two.Peers())

    // terminate subscription
    sub_one.Unsubscribe()

When the connection is completed (on the node we're subscribing to), we
output the logline as before. Don't feel guilty about terminating the
subscription after just one item. You'll get your money's worth later.

## 'Something to say'

You got someone's attention. Now on to the awkward moment of finding
what to say.

Were this a human scenario, we've probably collected a neat heap of
one-liners over time to be thrown out as warranted, sorted by crowd type
and end purpose.

Computers aren't all that different, but they like to call this stuff
protocol instead. However, computers aren't shy about sharing in advance
what phrases they like to hear from you. So if you like to be surprised,
this is not the domain for you.

When nodes connect, they tell each other which protocols they speak.
They then each start an event loop that listens for incoming messages
from the other, and associates all mutually spoken protocols with this
loop.

Then, as message are received, the code that gets called with the
associated protocol makes something happen in the node, and returns
whatever answer is appropriate for the occasion.

### Hello, peer

Let's define a protocol then. And as before, let's do the simplest one
we can think of:

1.  send a short message

2.  wait for a message in return

3.  disconnect

Protocols are defined using the `p2p.Protocol` struct. First of all it
defines some metadata:

    proto = p2p.Protocol{
    	Name:    "foo",
    	Version: 42,
    	Length:  1,

The meaning of `Name` and `Version` is likely self-evident. `Length` is
the number of different messages involved in this protocol (more on this
later).

We also define the code to be run:

    	Run: func(p *p2p.Peer, rw p2p.MsgReadWriter) error {

The Run-function has to have this signature. So then you know that you
will receive the `p2p.Peer` object to play around with, along with the
`p2p.MsgReadWriter` which can be written to and read from. Let's do
exactly that:

    		// simplest payload possible; a byte slice
    		outmsg := "foobar"

    		// send the message
    		err := p2p.Send(rw, 0, outmsg)

The `p2p.Send` takes the object to write to as the first argument, and
the message to send as the last. The message will take whatever data
type[^2] you submit to it and serialize it in a compact series of bytes
that can be rebuilt on the other side.

The second parameter is the _message code_. That will be explained a bit
further down. Moving on:

    		if err != nil {
    			return fmt.Errorf("Send p2p message fail: %v", err)
    		}

    		inmsg, err := rw.ReadMsg()

Notice that if an error occurs when sending, we `return` from the `Run`
function. That has the dire consequence of abruptly and rudely cutting
the connection off. Not to be done lightly, in other words.

Assuming that the connection survives, we call `ReadMsg` on the
`MsgReadWriter` object. This method will _block_ until a message comes
in from the other side.

### Teaching the node

We've defined the protocol. Node we need to tell the node to speak it.
This is a simple as slipping a couple of lines into the configuration:

    cfg := p2p.Config{
    	PrivateKey:      privkey,
    	Name:            common.MakeName(name, version),
    	MaxPeers:        1,
    	Protocols:       []p2p.Protocol{proto},
    	EnableMsgEvents: true,
    }

The `Protocols` member takes an array of protocols to add. That's all
that's really needed.

However, in this case we also set the `EnableMsgEvents` to true, so we
can listen for message events in the same manner we listened for
connection events in the previous chapter. They are disabled by default
to protect ourselves against excessive noise, I guess.

    // set up the event subscriptions on both servers
    // the Err() on the Subscription object returns when subscription is closed
    eventOneC := make(chan *p2p.PeerEvent)
    sub_one := srv_one.SubscribeEvents(eventOneC)
    messageW.Add(1)
    go func() {
    	for {
    		peerevent := <-eventOneC
    		if peerevent.Type == "add" {
    			demo.LogDebug("Received peer add notification on node #1", "peer", peerevent.Peer)
    		} else if peerevent.Type == "msgrecv" {
    			demo.LogInfo("Received message nofification on node #1", "event", peerevent)

    			messageW.Done()
    			return
    		}
    	}
    }()

Now that we have two different events to check for, we need to expand
the event listener function a bit. Since we'll be making sure that both
sides have received their expected messages, we use a `WaitGroup`
instead of a simple channel to wait at the end of the `main` function.
Then we simply check for the message type, and if it's
` ``msgrecv'' ` (guess what that means) we decrement the wait
counter and terminate the forked routine.

    	// wait for each respective message to be delivered on both sides
    	messageW.Wait()

    	// terminate subscription loops and unsubscribe
    	sub_one.Unsubscribe()
    	sub_two.Unsubscribe()

To finish, we call the appropriate `Wait()` and `Unsubscribe()`s, and
feel accomplished and hopefully a slight bit less lonely too after
having exchanged our first messages.

### Keeping up to code

I promised to tell you about the "00" in the `p2p.Send` call, remember?
It goes like this:

All protocols that are added to the node are numbered in sequential
order. More specifically all the _message types_ of the protocol are
numbered. Of course, our example only has one protocol and one message
type, and therefore the choice is easy to make. But if there are
multiple protocols involved, it gets a bit more ...well, involved.

Think back to the configuration of the `p2p.Protocol` object. There was
a member called `Length` there. We said that this declares the number of
different message types the protocol handles.

When a message is received, every one of the protocols are checked in
turn for how many message types they contain, and if the message `Code`
falls within those numbers.

Let's say we have three protocols registered. The first with `Length` 1,
second with `Length` 3, third with `Length` 2. The first message `Code`
index is 0. So if the received message has message `Code` 0, it belongs
to protocol _A_, because it is the first and has only one message. If it
has message `Code` 2, it matches protocol _B_ because, being `Length` 3
and directly following _A_ it has messages 1, 2 and 3. And if the
message has number 6 ...well, the protocol _C_ ends at 5, so that
message will be _unknown_ and return an error. Remember what happens
with errors in protocols? It means instant hangup. No farewell the
wells, no see you later alligators. Just "click". So beware!

[^1]:

  we will be truncating long hex strings in these tutorials. This is
  your last and final warning

[^2]:

  actually, there are some data types you cannot use. int is one of
  them. Don't worry about that for now. Anyway, you'll get an error if
  you try
